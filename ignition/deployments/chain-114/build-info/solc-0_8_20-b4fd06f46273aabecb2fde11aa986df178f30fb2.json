{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-b4fd06f46273aabecb2fde11aa986df178f30fb2",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/InsuranceContract.sol": "project/contracts/InsuranceContract.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/InsuranceContract.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract InsuranceContract is ReentrancyGuard {\n    // Data structure for a quote request\n    struct QuoteRequest {\n        address requester;\n        uint256 timestamp;\n        string metadata;      // e.g., insurance requirements / personal details reference\n        bool fulfilled;\n    }\n\n    // Data structure for an offer\n    struct Offer {\n        uint256 quoteRequestId;\n        address provider;\n        uint256 premium;         // premium amount the requester must pay\n        uint256 coverageAmount;  // amount covered in case of claim\n        uint256 validUntil;      // offer expiry timestamp\n        bool accepted;\n        bool premiumPaid;\n        bool coverageFunded;\n        bool payoutClaimed;\n    }\n\n    // Storage\n    QuoteRequest[] public quoteRequests;\n    Offer[] public offers;\n\n    // Mapping provider => available funds (to fund coverage)\n    mapping(address => uint256) public providerFunds;\n\n    // Events\n    event QuoteRequested(uint256 indexed quoteRequestId, address indexed requester);\n    event OfferMade(\n        uint256 indexed offerId,\n        uint256 indexed quoteRequestId,\n        address indexed provider,\n        uint256 premium,\n        uint256 coverageAmount,\n        uint256 validUntil\n    );\n    event PremiumPaid(uint256 indexed offerId, address indexed requester, uint256 amount);\n    event CoverageFunded(uint256 indexed offerId, address indexed provider, uint256 amount);\n    event OfferAccepted(uint256 indexed offerId, uint256 indexed quoteRequestId, address indexed requester);\n    event PayoutMade(uint256 indexed offerId, address indexed requester, uint256 payoutAmount);\n    event ProviderRefunded(uint256 indexed offerId, address indexed provider, uint256 amount);\n\n    // Function: request a quote\n    function getQuote(string memory metadata) external returns (uint256 quoteRequestId) {\n        quoteRequestId = quoteRequests.length;\n        quoteRequests.push(QuoteRequest({\n            requester: msg.sender,\n            timestamp: block.timestamp,\n            metadata: metadata,\n            fulfilled: false\n        }));\n        emit QuoteRequested(quoteRequestId, msg.sender);\n    }\n\n    // Function: provider makes an offer\n    function offer(\n        uint256 quoteRequestId,\n        uint256 premium,\n        uint256 coverageAmount,\n        uint256 validUntil\n    ) external returns (uint256 offerId) {\n        require(quoteRequestId < quoteRequests.length, \"Invalid quoteRequestId\");\n        QuoteRequest storage qr = quoteRequests[quoteRequestId];\n        require(!qr.fulfilled, \"Quote already fulfilled\");\n\n        offerId = offers.length;\n        offers.push(Offer({\n            quoteRequestId: quoteRequestId,\n            provider: msg.sender,\n            premium: premium,\n            coverageAmount: coverageAmount,\n            validUntil: validUntil,\n            accepted: false,\n            premiumPaid: false,\n            coverageFunded: false,\n            payoutClaimed: false\n        }));\n        emit OfferMade(offerId, quoteRequestId, msg.sender, premium, coverageAmount, validUntil);\n    }\n\n    // Function: provider deposits funds to fund coverage\n    function fundCoverage(uint256 offerId) external payable nonReentrant {\n        require(offerId < offers.length, \"Invalid offerId\");\n        Offer storage off = offers[offerId];\n        require(msg.sender == off.provider, \"Only provider may fund coverage\");\n        require(!off.coverageFunded, \"Coverage already funded\");\n        require(msg.value >= off.coverageAmount, \"Insufficient funding for coverage\");\n\n        off.coverageFunded = true;\n        providerFunds[msg.sender] += msg.value;\n        emit CoverageFunded(offerId, msg.sender, msg.value);\n    }\n\n    // Function: requester pays premium and accepts offer\n    function accept(uint256 offerId) external payable nonReentrant {\n        require(offerId < offers.length, \"Invalid offerId\");\n        Offer storage off = offers[offerId];\n        QuoteRequest storage qr = quoteRequests[off.quoteRequestId];\n\n        require(msg.sender == qr.requester, \"Only requester may accept\");\n        require(!off.accepted, \"Offer already accepted\");\n        require(block.timestamp <= off.validUntil, \"Offer expired\");\n        require(msg.value >= off.premium, \"Insufficient premium payment\");\n        require(off.coverageFunded, \"Coverage not yet funded by provider\");\n\n        off.premiumPaid = true;\n        off.accepted = true;\n        qr.fulfilled = true;\n\n        // Premium funds go to provider\n        providerFunds[off.provider] += msg.value;\n\n        emit PremiumPaid(offerId, msg.sender, msg.value);\n        emit OfferAccepted(offerId, off.quoteRequestId, msg.sender);\n    }\n\n    // Function: claimant requests payout after event validated (via FDC)\n    function claimPayout(uint256 offerId) external nonReentrant {\n        require(offerId < offers.length, \"Invalid offerId\");\n        Offer storage off = offers[offerId];\n        QuoteRequest storage qr = quoteRequests[off.quoteRequestId];\n\n        require(off.accepted, \"Offer not accepted\");\n        require(msg.sender == qr.requester, \"Only requester may claim\");\n        require(!off.payoutClaimed, \"Payout already claimed\");\n        // Additional require: claim validated via FDC oracle call (to integrate)\n        // e.g., require(eventOccurred(â€¦)==true, \"No valid claim event\");\n\n        off.payoutClaimed = true;\n\n        uint256 payout = off.coverageAmount;\n        // deduct payout from providerFunds\n        require(providerFunds[off.provider] >= payout, \"Provider underfunded\");\n        providerFunds[off.provider] -= payout;\n\n        (bool success,) = msg.sender.call{ value: payout }(\"\");\n        require(success, \"Payout transfer failed\");\n\n        emit PayoutMade(offerId, msg.sender, payout);\n    }\n\n    // Function: provider refund if no claim after expiry\n    function refundProvider(uint256 offerId) external nonReentrant {\n        require(offerId < offers.length, \"Invalid offerId\");\n        Offer storage off = offers[offerId];\n\n        require(off.provider == msg.sender, \"Only provider may refund\");\n        require(off.accepted == false, \"Offer was accepted; cannot refund\");\n        require(block.timestamp > off.validUntil, \"Offer not yet expired\");\n        require(off.coverageFunded, \"Coverage not funded\");\n\n        off.coverageFunded = false;\n\n        uint256 refundAmount = off.coverageAmount;\n        require(providerFunds[msg.sender] >= refundAmount, \"Insufficient funds to refund\");\n        providerFunds[msg.sender] -= refundAmount;\n\n        (bool success,) = msg.sender.call{ value: refundAmount }(\"\");\n        require(success, \"Refund transfer failed\");\n\n        emit ProviderRefunded(offerId, msg.sender, refundAmount);\n    }\n\n    // Function: view provider available funds\n    function getProviderFunds(address provider) external view returns (uint256) {\n        return providerFunds[provider];\n    }\n}\n"
      }
    }
  }
}